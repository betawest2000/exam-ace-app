// JS Starter Code
const jsStarterCode = "export class BinaryTreeNode {\n  /**\n   * Initialize a Binary Tree node.\n   * @param {*} value The value of the node.\n   */\n  constructor(value) {\n    throw \"Not implemented!\";\n  }\n}\n\nexport class BinaryTree {\n  /**\n   * Initialize the Binary Tree.\n   * @param {*} value The value of the root node.\n   */\n  constructor(value) {\n    throw \"Not implemented!\";\n  }\n\n  /**\n   * Get the number of nodes in the tree.\n   * @return {number} The number of nodes in the tree.\n   */\n  size() {\n    throw \"Not implemented!\";\n  }\n\n  /**\n   * Get the height of the tree.\n   * @return {number} The height of the tree.\n   */\n  height() {\n    throw \"Not implemented!\";\n  }\n\n  /**\n   * Traverse the tree in an in-order fashion.\n   * @return {Array<*>} An array of values of the nodes in in-order traversal.\n   */\n  inOrder() {\n    throw \"Not implemented!\";\n  }\n\n  /**\n   * Traverse the tree in a pre-order fashion.\n   * @return {Array<*>} An array of values of the nodes in pre-order traversal.\n   */\n  preOrder() {\n    throw \"Not implemented!\";\n  }\n\n  /**\n   * Traverse the tree in a post-order fashion.\n   * @return {Array<*>} An array of values of the nodes in post-order traversal.\n   */\n  postOrder() {\n    throw \"Not implemented!\";\n  }\n\n  /**\n   * Checks if the binary tree is balanced, i.e. depth of the two subtrees of\n   * every node never differ by more than 1.\n   * @return {boolean}\n   */\n  isBalanced() {\n    throw \"Not implemented!\";\n  }\n\n  /**\n   * Checks if the binary tree is complete, i.e., all levels are completely filled except possibly the last level,\n   * which is filled from left to right.\n   * @return {boolean} True if the binary tree is complete, false otherwise.\n   */\n  isComplete() {\n    throw \"Not implemented!\";\n  }\n}\n";

// TS Starter Code
const tsStarterCode = "export class BinaryTreeNode<T> {\n  public value: T;\n  public left: BinaryTreeNode<T> | null;\n  public right: BinaryTreeNode<T> | null;\n\n  /**\n   * Initialize a Binary Tree node.\n   * @param {T} value The value of the node.\n   */\n  constructor(value?: T) {\n    throw \"Not implemented!\";\n  }\n}\n\nexport class BinaryTree<T> {\n  /**\n   * Initialize the Binary Tree.\n   * @param {T} value The value of the root node.\n   */\n  constructor(value?: T) {\n    throw \"Not implemented!\";\n  }\n\n  /**\n   * Get the number of nodes in the tree.\n   * @return {number} The number of nodes in the tree.\n   */\n  size(): number {\n    throw \"Not implemented!\";\n  }\n\n  /**\n   * Get the height of the tree.\n   * @return {number} The height of the tree.\n   */\n  height(): number {\n    throw \"Not implemented!\";\n  }\n\n  /**\n   * Traverse the tree in an in-order fashion.\n   * @return {Array<T>} An array of values of the nodes in in-order traversal.\n   */\n  inOrder(): Array<T> {\n    throw \"Not implemented!\";\n  }\n\n  /**\n   * Traverse the tree in a pre-order fashion.\n   * @return {Array<T>} An array of values of the nodes in pre-order traversal.\n   */\n  preOrder(): Array<T> {\n    throw \"Not implemented!\";\n  }\n\n  /**\n   * Traverse the tree in a post-order fashion.\n   * @return {Array<T>} An array of values of the nodes in post-order traversal.\n   */\n  postOrder(): Array<T> {\n    throw \"Not implemented!\";\n  }\n\n  /**\n   * Checks if the binary tree is balanced, i.e. depth of the two subtrees of\n   * every node never differ by more than 1.\n   * @return {boolean}\n   */\n  isBalanced(): boolean {\n    throw \"Not implemented!\";\n  }\n\n  /**\n   * Checks if the binary tree is complete, i.e., all levels are completely filled except possibly the last level,\n   * which is filled from left to right.\n   * @return {boolean} True if the binary tree is complete, false otherwise.\n   */\n  isComplete(): boolean {\n    throw \"Not implemented!\";\n  }\n}\n";

// JS Test Cases
const jsTestCode = "import { BinaryTree, BinaryTreeNode } from \"./binary-tree\";\n\nfunction createTree() {\n  const tree = new BinaryTree(\"F\");\n  const root = tree.root!;\n  root.left = new BinaryTreeNode(\"B\");\n  root.left.left = new BinaryTreeNode(\"A\");\n  root.left.right = new BinaryTreeNode(\"D\");\n  root.left.right.left = new BinaryTreeNode(\"C\");\n  root.left.right.right = new BinaryTreeNode(\"E\");\n  root.right = new BinaryTreeNode(\"G\");\n  root.right.right = new BinaryTreeNode(\"I\");\n  root.right.right.left = new BinaryTreeNode(\"H\");\n  return tree;\n}\n\ndescribe(\"BinaryTree\", () => {\n  describe(\"constructor()\", () => {\n    test(\"empty tree\", () => {\n      const tree = new BinaryTree();\n      expect(tree).toBeTruthy();\n      expect(tree.root).toBe(null);\n    });\n\n    test(\"one-node tree\", () => {\n      const { root } = new BinaryTree(5);\n      expect(root?.value).toBe(5);\n    });\n  });\n\n  describe(\"root\", () => {\n    test(\"empty tree\", () => {\n      const { root } = new BinaryTree();\n      expect(root).toBe(null);\n    });\n\n    test(\"one-node tree\", () => {\n      const { root } = new BinaryTree(5);\n      expect(root?.value).toBe(5);\n    });\n  });\n\n  describe(\"size()\", () => {\n    test(\"empty tree\", () => {\n      const tree = new BinaryTree();\n      expect(tree.size()).toBe(0);\n    });\n\n    test(\"one-node tree\", () => {\n      const tree = new BinaryTree(10);\n      expect(tree.size()).toBe(1);\n    });\n\n    test(\"two-node tree\", () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.left = new BinaryTreeNode(5);\n      expect(tree.size()).toBe(2);\n    });\n\n    test(\"non-empty tree\", () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.left = new BinaryTreeNode(5);\n      root.left.left = new BinaryTreeNode(15);\n      root.right = new BinaryTreeNode(2);\n      expect(tree.size()).toBe(4);\n    });\n  });\n\n  describe(\"height()\", () => {\n    test(\"empty tree\", () => {\n      const tree = new BinaryTree();\n      expect(tree.height()).toBe(0);\n    });\n\n    test(\"one-node tree\", () => {\n      const tree = new BinaryTree(10);\n      expect(tree.height()).toBe(0);\n    });\n\n    test(\"two-node tree\", () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.left = new BinaryTreeNode(5);\n      expect(tree.height()).toBe(1);\n    });\n\n    test(\"non-empty tree\", () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.left = new BinaryTreeNode(5);\n      root.left.left = new BinaryTreeNode(15);\n      root.right = new BinaryTreeNode(2);\n      expect(tree.height()).toBe(2);\n    });\n  });\n\n  describe(\"inOrder()\", () => {\n    test(\"empty tree\", () => {\n      const tree = new BinaryTree();\n      expect(tree.inOrder()).toEqual([]);\n    });\n\n    test(\"one-node tree\", () => {\n      const tree = new BinaryTree(10);\n      expect(tree.inOrder()).toEqual([10]);\n    });\n\n    test(\"three-node tree\", () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.left = new BinaryTreeNode(5);\n      root.right = new BinaryTreeNode(15);\n      expect(tree.inOrder()).toEqual([5, 10, 15]);\n    });\n\n    test(\"non-empty tree\", () => {\n      const tree = createTree();\n      expect(tree.inOrder()).toEqual([\n        \"A\",\n        \"B\",\n        \"C\",\n        \"D\",\n        \"E\",\n        \"F\",\n        \"G\",\n        \"H\",\n        \"I\",\n      ]);\n    });\n  });\n\n  describe(\"preOrder()\", () => {\n    test(\"empty tree\", () => {\n      const tree = new BinaryTree();\n      expect(tree.preOrder()).toEqual([]);\n    });\n\n    test(\"one-node tree\", () => {\n      const tree = new BinaryTree(10);\n      expect(tree.preOrder()).toEqual([10]);\n    });\n\n    test(\"three-node tree\", () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.left = new BinaryTreeNode(5);\n      root.right = new BinaryTreeNode(15);\n      expect(tree.preOrder()).toEqual([10, 5, 15]);\n    });\n\n    test(\"non-empty tree\", () => {\n      const tree = createTree();\n      expect(tree.preOrder()).toEqual([\n        \"F\",\n        \"B\",\n        \"A\",\n        \"D\",\n        \"C\",\n        \"E\",\n        \"G\",\n        \"I\",\n        \"H\",\n      ]);\n    });\n  });\n\n  describe(\"postOrder()\", () => {\n    test(\"empty tree\", () => {\n      const tree = new BinaryTree();\n      expect(tree.postOrder()).toEqual([]);\n    });\n\n    test(\"one-node tree\", () => {\n      const tree = new BinaryTree(10);\n      expect(tree.postOrder()).toEqual([10]);\n    });\n\n    test(\"three-node tree\", () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.left = new BinaryTreeNode(5);\n      root.right = new BinaryTreeNode(15);\n      expect(tree.postOrder()).toEqual([5, 15, 10]);\n    });\n\n    test(\"non-empty tree\", () => {\n      const tree = createTree();\n      expect(tree.postOrder()).toEqual([\n        \"A\",\n        \"C\",\n        \"E\",\n        \"D\",\n        \"B\",\n        \"H\",\n        \"I\",\n        \"G\",\n        \"F\",\n      ]);\n    });\n  });\n\n  describe(\"isBalanced()\", () => {\n    test(\"empty tree\", () => {\n      const tree = new BinaryTree();\n      expect(tree.isBalanced()).toBe(true);\n    });\n\n    test(\"one-node tree\", () => {\n      const tree = new BinaryTree(10);\n      expect(tree.isBalanced()).toBe(true);\n    });\n\n    test(\"three-node tree\", () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.left = new BinaryTreeNode(5);\n      root.right = new BinaryTreeNode(15);\n      expect(tree.isBalanced()).toBe(true);\n    });\n\n    test(\"linked-list tree\", () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.right = new BinaryTreeNode(15);\n      root.right.right = new BinaryTreeNode(20);\n      expect(tree.isBalanced()).toBe(false);\n    });\n\n    test(\"non-empty tree\", () => {\n      const tree = createTree();\n      expect(tree.isBalanced()).toBe(false);\n    });\n  });\n\n  describe(\"isComplete()\", () => {\n    test(\"empty tree\", () => {\n      const tree = new BinaryTree();\n      expect(tree.isComplete()).toBe(true);\n    });\n\n    test(\"one-node tree\", () => {\n      const tree = new BinaryTree(10);\n      expect(tree.isComplete()).toBe(true);\n    });\n\n    test(\"two-node tree left\", () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.left = new BinaryTreeNode(5);\n      expect(tree.isComplete()).toBe(true);\n    });\n\n    test(\"two-node tree right\", () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.right = new BinaryTreeNode(5);\n      expect(tree.isComplete()).toBe(false);\n    });\n\n    test(\"three-node tree\", () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.left = new BinaryTreeNode(5);\n      root.right = new BinaryTreeNode(15);\n      expect(tree.isComplete()).toBe(true);\n    });\n\n    test(\"linked-list tree\", () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.right = new BinaryTreeNode(15);\n      root.right.right = new BinaryTreeNode(20);\n      expect(tree.isComplete()).toBe(false);\n    });\n  });\n});\n";

// TS Test Cases
const tsTestCode = jsTestCode; 

// JS Test File Name
const jsTestFileName = "submission.spec.ts";

// TS Test File Name
const tsTestFileName = "submission.spec.ts";
// Additional Files
const additionalFiles = {} as Record<string, string>;

const code = {
  jsStarterCode,
  tsStarterCode,
  jsTestCode,
  tsTestCode,
  jsTestFileName,
  tsTestFileName,
  additionalFiles,
} as Record<string, string | Record<string, string>>;

// Export the code object
export default code;
