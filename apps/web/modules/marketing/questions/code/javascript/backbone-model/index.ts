// JS Starter Code
const jsStarterCode = "// You are free to use alternative approaches of\n// defining BackboneModel as long as the\n// default export can be instantiated.\nexport default class BackboneModel {\n  /**\n   * @param {Object} initialValues\n   * @returns BackboneModel\n   */\n  constructor(initialValues) {\n    throw \"Not implemented!\";\n  }\n\n  /**\n   * Get the value of a specific attribute.\n   * @param {string} attribute - The attribute name.\n   * @returns {any | undefined} The value of the attribute.\n   */\n  get(attribute) {\n    throw \"Not implemented!\";\n  }\n\n  /**\n   * Set the value of a specific attribute.\n   * @param {string} attribute - The attribute name.\n   * @param {any} value - The value to set for the attribute.\n   */\n  set(attribute, value) {\n    throw \"Not implemented!\";\n  }\n\n  /**\n   * Check if the model has a specific attribute.\n   * @param {string} attribute - The attribute name.\n   * @returns {boolean} `true` if the model has the attribute, `false` otherwise.\n   */\n  has(attribute) {\n    throw \"Not implemented!\";\n  }\n\n  /**\n   * Unset a specific attribute.\n   * @param {string} attribute - The attribute name to unset.\n   */\n  unset(attribute) {\n    throw \"Not implemented!\";\n  }\n\n  /**\n   * Register an event listener for changes to a specific attribute.\n   * @param {string} eventName - The event name.\n   * @param {string} attribute - The attribute name to listen for changes.\n   * @param {Function} callback - The callback function to be executed on the event.\n   * @param {any} [context] - The context in which to execute the callback.\n   */\n  on(eventName, attribute, callback, context) {\n    throw \"Not implemented!\";\n  }\n\n  /**\n   * Remove an event listener for changes to a specific attribute.\n   * @param {string} eventName - The event name.\n   * @param {string} attribute - The attribute name to stop listening for changes.\n   * @param {Function} callback - The callback function to remove.\n   */\n  off(eventName, attribute, callback) {\n    throw \"Not implemented!\";\n  }\n}\n";

// TS Starter Code
const tsStarterCode = "type EventName = \"change\" | \"unset\";\n\ninterface IBackboneModel {\n  get(attribute: string): unknown | undefined;\n  set(attribute: string, value: unknown): void;\n  has(attribute: string): boolean;\n  unset(attribute: string): void;\n  on(\n    eventName: EventName,\n    attribute: string,\n    callback: Function,\n    context?: any,\n  ): void;\n  off(event: EventName, attribute: string, callback: Function): void;\n}\n\n// You are free to use alternative approaches of\n// defining BackboneModel as long as the\n// default export can be instantiated.\nexport default class BackboneModel implements IBackboneModel {\n  constructor(initialValues: Record<string, unknown> = {}) {\n    throw \"Not implemented!\";\n  }\n\n  get(attribute: string): unknown | undefined {\n    throw \"Not implemented!\";\n  }\n\n  set(attribute: string, value: unknown): void {\n    throw \"Not implemented!\";\n  }\n\n  has(attribute: string): boolean {\n    throw \"Not implemented!\";\n  }\n\n  unset(attribute: string): void {\n    throw \"Not implemented!\";\n  }\n\n  on(\n    eventName: EventName,\n    attribute: string,\n    callback: Function,\n    context?: any,\n  ): void {\n    throw \"Not implemented!\";\n  }\n\n  off(eventName: EventName, attribute: string, callback: Function): void {\n    throw \"Not implemented!\";\n  }\n}\n";

// JS Test Cases
const jsTestCode = "import BackboneModel from \"./backbone-model\";\n\ndescribe(\"BackboneModel\", () => {\n  describe(\"constructor\", () => {\n    test(\"without default data\", () => {\n      const person = new BackboneModel();\n      expect(person).toBeInstanceOf(BackboneModel);\n    });\n\n    test(\"with default data\", () => {\n      const person = new BackboneModel({ name: \"John\", age: 30 });\n      expect(person).toBeInstanceOf(BackboneModel);\n    });\n  });\n\n  describe(\"get\", () => {\n    test(\"existing field\", () => {\n      const person = new BackboneModel({ name: \"John\", age: 30 });\n      expect(person.get(\"name\")).toBe(\"John\");\n      expect(person.get(\"age\")).toBe(30);\n    });\n\n    test(\"non-existing field\", () => {\n      const person = new BackboneModel();\n      expect(person.get(\"name\")).toBeUndefined();\n    });\n  });\n\n  describe(\"set\", () => {\n    test(\"new field\", () => {\n      const person = new BackboneModel();\n      person.set(\"name\", \"Carol\");\n\n      expect(person.get(\"name\")).toBe(\"Carol\");\n    });\n\n    test(\"existing field\", () => {\n      const person = new BackboneModel({ name: \"John\", age: 30 });\n      expect(person.get(\"name\")).toBe(\"John\");\n\n      person.set(\"name\", \"Carol\");\n      expect(person.get(\"name\")).toBe(\"Carol\");\n    });\n  });\n\n  describe(\"has\", () => {\n    test(\"existing field\", () => {\n      const person = new BackboneModel({ name: \"John\" });\n      expect(person.has(\"name\")).toBe(true);\n    });\n\n    test(\"non-existing field\", () => {\n      const person = new BackboneModel({ name: \"John\" });\n      expect(person.has(\"age\")).toBe(false);\n    });\n  });\n\n  describe(\"unset\", () => {\n    test(\"existing field\", () => {\n      const person = new BackboneModel({ name: \"John\", age: 30 });\n      expect(person.has(\"name\")).toBe(true);\n      person.unset(\"name\");\n\n      expect(person.has(\"name\")).toBe(false);\n    });\n\n    test(\"non-existing field\", () => {\n      const person = new BackboneModel({ name: \"John\" });\n      person.unset(\"age\");\n\n      expect(person.has(\"age\")).toBe(false);\n    });\n  });\n\n  describe(\"on\", () => {\n    describe(\"change event\", () => {\n      test(\"callback invoked when attribute changes\", () => {\n        let fired = false;\n        const person = new BackboneModel({ name: \"John\" });\n        person.on(\"change\", \"name\", () => {\n          fired = true;\n        });\n        person.set(\"name\", \"Johnny\");\n\n        expect(person.get(\"name\")).toBe(\"Johnny\");\n        expect(fired).toBe(true);\n      });\n\n      test(\"callback invoked with correct arguments\", () => {\n        let args: Array<any> = [];\n        const person = new BackboneModel({ name: \"John\" });\n        person.on(\"change\", \"name\", (...args_: Array<any>) => {\n          args = args_;\n        });\n        person.set(\"name\", \"Johnny\");\n\n        expect(person.get(\"name\")).toBe(\"Johnny\");\n        expect(args).toEqual([\"name\", \"Johnny\", \"John\"]);\n      });\n\n      test(\"callback invoked with `this`\", () => {\n        let user = { name: \"Boo\" };\n        const person = new BackboneModel({ name: \"John\" });\n        person.on(\n          \"change\",\n          \"name\",\n          function (\n            this: any,\n            attribute: string,\n            newValue: any,\n            _oldValue: any,\n          ) {\n            this[attribute] = newValue;\n          },\n          user,\n        );\n        expect(user.name).toBe(\"Boo\");\n\n        person.set(\"name\", \"Johnny\");\n        expect(person.get(\"name\")).toBe(\"Johnny\");\n        expect(user.name).toEqual(\"Johnny\");\n      });\n\n      test(\"works for multiple changes\", () => {\n        let args: Array<any> = [];\n\n        const person = new BackboneModel({ name: \"John\" });\n        person.on(\"change\", \"name\", (...args_: Array<any>) => {\n          args = args_;\n        });\n\n        person.set(\"name\", \"Johnny\");\n        expect(person.get(\"name\")).toBe(\"Johnny\");\n        expect(args).toEqual([\"name\", \"Johnny\", \"John\"]);\n\n        person.set(\"name\", \"Carol\");\n        expect(person.get(\"name\")).toBe(\"Carol\");\n        expect(args).toEqual([\"name\", \"Carol\", \"Johnny\"]);\n      });\n\n      test(\"does not fire when no change\", () => {\n        let times = 0;\n        function callback() {\n          times++;\n        }\n\n        const person = new BackboneModel({ name: \"John\" });\n        person.on(\"change\", \"name\", callback);\n\n        person.set(\"name\", \"Johnny\");\n        expect(person.get(\"name\")).toBe(\"Johnny\");\n        expect(times).toEqual(1);\n\n        person.set(\"name\", \"Johnny\");\n        expect(person.get(\"name\")).toBe(\"Johnny\");\n        expect(times).toEqual(1);\n      });\n\n      test(\"removed when unset\", () => {\n        let times = 0;\n\n        const person = new BackboneModel({ name: \"John\" });\n        person.on(\"change\", \"name\", () => {\n          times++;\n        });\n\n        person.set(\"name\", \"Johnny\");\n        expect(person.get(\"name\")).toBe(\"Johnny\");\n        expect(times).toBe(1);\n\n        person.unset(\"name\");\n        person.set(\"name\", \"Carol\");\n        person.set(\"name\", \"Caroline\");\n        expect(times).toBe(1);\n      });\n    });\n\n    describe(\"unset event\", () => {\n      test(\"callback invoked when attribute unset\", () => {\n        let fired = false;\n        const person = new BackboneModel({ name: \"John\" });\n        person.on(\"unset\", \"name\", () => {\n          fired = true;\n        });\n        person.unset(\"name\");\n\n        expect(fired).toBe(true);\n        expect(person.get(\"name\")).toBeUndefined();\n      });\n\n      test(\"callback invoked with correct arguments\", () => {\n        let args: Array<any> = [];\n        const person = new BackboneModel({ name: \"John\" });\n        person.on(\"unset\", \"name\", (...args_: Array<any>) => {\n          args = args_;\n        });\n        person.unset(\"name\");\n\n        expect(args).toEqual([\"name\"]);\n        expect(person.get(\"name\")).toBeUndefined();\n      });\n\n      test(\"callback invoked with `this`\", () => {\n        let unsetAttribute = { name: null };\n        const person = new BackboneModel({ name: \"John\" });\n        person.on(\n          \"unset\",\n          \"name\",\n          function (this: any, attribute: string) {\n            this.name = attribute;\n          },\n          unsetAttribute,\n        );\n        expect(unsetAttribute.name).toBeNull();\n        person.unset(\"name\");\n\n        expect(person.get(\"name\")).toBeUndefined();\n        expect(unsetAttribute.name).toEqual(\"name\");\n      });\n    });\n\n    test(\"non-existing attribute does not error\", () => {\n      const person = new BackboneModel();\n      expect(() => {\n        person.on(\"change\", \"boo\", () => {});\n      }).not.toThrow();\n    });\n\n    test(\"not called after the attribute is initially set\", () => {\n      let times = 0;\n      function callback() {\n        times++;\n      }\n      const person = new BackboneModel();\n      person.on(\"change\", \"name\", callback);\n\n      person.set(\"name\", \"John\");\n      expect(times).toBe(0);\n    });\n\n    describe(\"multiple callbacks\", () => {\n      test(\"same callback can be added multiple times for the same attribute and event\", () => {\n        let times = 0;\n        function callback() {\n          times++;\n        }\n        const person = new BackboneModel({ name: \"John\" });\n        person.on(\"change\", \"name\", callback);\n        person.on(\"change\", \"name\", callback);\n\n        person.set(\"name\", \"Johnny\");\n        expect(times).toBe(2);\n      });\n\n      test(\"different callbacks for the same attribute and event\", () => {\n        let foo = 0;\n        let bar = 0;\n        function fooIncrement() {\n          foo++;\n        }\n        function barIncrement() {\n          bar++;\n        }\n\n        const person = new BackboneModel({ name: \"John\" });\n        person.on(\"change\", \"name\", fooIncrement);\n        person.on(\"change\", \"name\", barIncrement);\n\n        person.set(\"name\", \"Johnny\");\n        expect(foo).toBe(1);\n        expect(bar).toBe(1);\n      });\n    });\n\n    test(\"event callbacks are isolated within instances\", () => {\n      let times = 0;\n      function callback() {\n        times++;\n      }\n\n      const john = new BackboneModel({ name: \"John\", age: 32 });\n      const _carol = new BackboneModel({ name: \"Carol\", age: 36 });\n\n      john.on(\"change\", \"age\", callback);\n      john.set(\"age\", 33);\n      expect(john.get(\"age\")).toBe(33);\n      expect(times).toEqual(1);\n    });\n  });\n\n  describe(\"off\", () => {\n    test(\"works for `change`\", () => {\n      let times = 0;\n      function callback() {\n        times++;\n      }\n\n      const person = new BackboneModel({ name: \"John\" });\n      person.on(\"change\", \"name\", callback);\n\n      person.set(\"name\", \"Johnny\");\n      expect(person.get(\"name\")).toBe(\"Johnny\");\n      expect(times).toEqual(1);\n\n      person.set(\"name\", \"Carol\");\n      expect(person.get(\"name\")).toBe(\"Carol\");\n      expect(times).toEqual(2);\n\n      person.off(\"change\", \"name\", callback);\n      person.set(\"name\", \"Caroline\");\n      expect(person.get(\"name\")).toBe(\"Caroline\");\n      expect(times).toEqual(2);\n    });\n\n    test(\"works for `unset`\", () => {\n      let times = 0;\n      function callback() {\n        times++;\n      }\n\n      const person = new BackboneModel({ name: \"John\" });\n      person.on(\"unset\", \"name\", callback);\n\n      person.set(\"name\", \"Johnny\");\n      expect(person.get(\"name\")).toBe(\"Johnny\");\n\n      person.off(\"unset\", \"name\", callback);\n      person.unset(\"name\");\n      expect(person.get(\"name\")).toBeUndefined();\n      expect(times).toEqual(0);\n    });\n\n    test(\"callbacks can be removed individually\", () => {\n      let foo = 0;\n      let bar = 0;\n      function fooIncrement() {\n        foo++;\n      }\n      function barIncrement() {\n        bar++;\n      }\n\n      const person = new BackboneModel({ name: \"John\" });\n      person.on(\"change\", \"name\", fooIncrement);\n      person.on(\"change\", \"name\", barIncrement);\n\n      person.set(\"name\", \"Johnny\");\n      expect(foo).toBe(1);\n      expect(bar).toBe(1);\n\n      person.off(\"change\", \"name\", fooIncrement);\n\n      person.set(\"name\", \"Carol\");\n      expect(foo).toBe(1);\n      expect(bar).toBe(2);\n    });\n  });\n\n  test(\"integration\", () => {\n    let times = 0;\n    function callback() {\n      times++;\n    }\n\n    const person = new BackboneModel({ name: \"John\", age: 32 });\n    expect(person.has(\"name\")).toBe(true);\n    expect(person.has(\"age\")).toBe(true);\n\n    person.on(\"change\", \"name\", callback);\n    person.on(\"change\", \"age\", callback);\n    person.on(\"unset\", \"name\", callback);\n\n    person.set(\"name\", \"Johnny\");\n    expect(person.get(\"name\")).toBe(\"Johnny\");\n    expect(times).toEqual(1);\n\n    person.set(\"name\", \"Johnny\");\n    expect(person.get(\"name\")).toBe(\"Johnny\");\n    expect(times).toEqual(1);\n\n    person.unset(\"name\");\n    expect(times).toEqual(2);\n    expect(person.has(\"name\")).toBe(false);\n\n    person.set(\"age\", 33);\n    expect(person.get(\"age\")).toBe(33);\n    expect(times).toEqual(3);\n\n    person.off(\"change\", \"age\", callback);\n    expect(person.set(\"age\", 34));\n    expect(times).toEqual(3);\n  });\n});\n";

// TS Test Cases
const tsTestCode = jsTestCode; 

// JS Test File Name
const jsTestFileName = "submission.spec.ts";

// TS Test File Name
const tsTestFileName = "submission.spec.ts";
// Additional Files
const additionalFiles = {} as Record<string, string>;

const code = {
  jsStarterCode,
  tsStarterCode,
  jsTestCode,
  tsTestCode,
  jsTestFileName,
  tsTestFileName,
  additionalFiles,
} as Record<string, string | Record<string, string>>;

// Export the code object
export default code;
