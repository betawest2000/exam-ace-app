// JS Starter Code
const jsStarterCode = "/**\n * @param {Object} objectParam\n * @param {string|Array<string>} pathParam\n * @param {*} [defaultValue]\n * @return {*}\n */\nexport default function get(objectParam, pathParam, defaultValue) {\n  throw \"Not implemented!\";\n}\n";

// TS Starter Code
const tsStarterCode = "export default function get<T>(\n  objectParam: Record<string, any>,\n  pathParam: string | Array<string>,\n  defaultValue?: T,\n): T {\n  throw \"Not implemented!\";\n}\n";

// JS Test Cases
const jsTestCode = "import get from \"./get\";\n\ndescribe(\"get\", () => {\n  describe(\"when the object is empty\", () => {\n    test(\"should return undefined for a simple path\", () => {\n      expect(get({}, \"a\")).toEqual(undefined);\n    });\n\n    test(\"should return undefined for a nested path\", () => {\n      expect(get({}, \"a.b\")).toEqual(undefined);\n    });\n  });\n\n  describe(\"when the path contains one segment\", () => {\n    test(\"should return the value if the path exists\", () => {\n      expect(get({ a: 1 }, \"a\")).toEqual(1);\n    });\n\n    test(\"should return undefined if the path does not exist\", () => {\n      expect(get({ c: 2 }, \"b\")).toEqual(undefined);\n    });\n\n    test(\"should return an object if the path leads to an object\", () => {\n      expect(get({ c: { foo: 1 } }, \"c\")).toEqual({ foo: 1 });\n    });\n  });\n\n  describe(\"when the path contains two segments\", () => {\n    test(\"should return the nested value if the path exists\", () => {\n      expect(get({ a: { b: 2 }, c: 1 }, \"a.b\")).toEqual(2);\n    });\n\n    test(\"should return undefined if an intermediate path segment does not exist\", () => {\n      expect(get({ a: { b: 2 }, c: 1 }, \"a.c\")).toEqual(undefined);\n    });\n\n    test(\"should return a nested object if the path leads to an object\", () => {\n      expect(get({ a: { b: 2, c: { foo: 2 } } }, \"a.c\")).toEqual({\n        foo: 2,\n      });\n    });\n  });\n\n  describe(\"when the path contains multiple segments\", () => {\n    test(\"should return the deeply nested value if the path exists\", () => {\n      expect(get({ a: { b: 2, c: { d: 0 } }, c: 1 }, \"a.c.d\")).toEqual(0);\n    });\n\n    test(\"should return undefined if a later path segment does not exist\", () => {\n      expect(get({ a: { b: 2 }, c: 1 }, \"a.c.e.f\")).toEqual(undefined);\n    });\n\n    test(\"should return a deeply nested object if the path leads to an object\", () => {\n      expect(\n        get({ a: { b: 2, c: { d: { e: { foo: 3 } } } }, c: 1 }, \"a.c.d.e\"),\n      ).toEqual({ foo: 3 });\n    });\n  });\n\n  describe(\"when accessing array values via path\", () => {\n    test(\"should return the value at the specified array index\", () => {\n      expect(get({ a: { b: [1, 2, 3], c: { d: 0 } }, c: 1 }, \"a.b.2\")).toEqual(\n        3,\n      );\n    });\n\n    test(\"should return nested values within objects inside arrays\", () => {\n      expect(\n        get(\n          { a: { b: [1, 2, 3, { c: \"bar\" }], c: { d: 0 } }, c: 1 },\n          \"a.b.3.c\",\n        ),\n      ).toEqual(\"bar\");\n    });\n\n    test(\"should return nested values within objects inside arrays using array as a path\", () => {\n      expect(\n        get({ a: { b: [1, 2, 3, { c: \"bar\" }], c: { d: 0 } }, c: 1 }, [\n          \"a\",\n          \"b\",\n          3,\n          \"c\",\n        ]),\n      ).toEqual(\"bar\");\n    });\n  });\n\n  describe(\"when a default value is provided\", () => {\n    test(\"should return the default value for an empty object and simple path\", () => {\n      expect(get({}, \"a\", 1)).toEqual(1);\n    });\n\n    test(\"should return the default value for an empty object and nested path\", () => {\n      expect(get({}, \"a.b\", 2)).toEqual(2);\n    });\n\n    test(\"should return the default value when the path does not exist in a non-empty object\", () => {\n      expect(get({ c: 2 }, \"b\", 3)).toEqual(3);\n    });\n  });\n\n  describe(\"when the path resolves to a null value\", () => {\n    test(\"should return null for a top-level null value\", () => {\n      expect(get({ b: null }, \"b\")).toEqual(null);\n    });\n\n    test(\"should return null for a nested null value\", () => {\n      expect(get({ a: { b: 2, c: null }, c: 1 }, \"a.c\")).toEqual(null);\n    });\n\n    test(\"should return null for a deeply nested null value\", () => {\n      expect(\n        get({ a: { b: 2, c: { d: { e: null } } }, c: 1 }, \"a.c.d.e\"),\n      ).toEqual(null);\n    });\n  });\n\n  describe(\"when the path is provided as an array\", () => {\n    test(\"should return the value for a single-element path array\", () => {\n      expect(get({ a: { b: 2 }, c: 1 }, [\"c\"])).toEqual(1);\n    });\n\n    test(\"should return undefined if an intermediate path segment does not exist\", () => {\n      expect(get({ a: { b: 2 }, c: 1 }, [\"a\", \"c\"])).toEqual(undefined);\n    });\n\n    test(\"should return a nested object if the path leads to an object\", () => {\n      expect(get({ a: { b: 2, c: { foo: 2 } } }, [\"a\", \"c\"])).toEqual({\n        foo: 2,\n      });\n    });\n\n    test(\"should handle array indices within the path array correctly\", () => {\n      expect(\n        get({ a: { b: [1, 2, 3, { c: \"bar\" }], c: { d: 0 } }, c: 1 }, [\n          \"a\",\n          \"b\",\n          \"3\",\n          \"c\",\n        ]),\n      ).toEqual(\"bar\");\n    });\n  });\n\n  describe(\"when attempting to access properties on non-object/array values\", () => {\n    test(\"should return undefined when accessing property on boolean\", () => {\n      expect(get({ a: { b: true } }, \"a.b.c\")).toEqual(undefined);\n    });\n\n    test(\"should return undefined when accessing property on null\", () => {\n      expect(get({ a: { b: null } }, \"a.b.c\")).toEqual(undefined);\n    });\n\n    test(\"should return undefined when accessing property on undefined\", () => {\n      expect(get({ a: { b: undefined } }, \"a.b.c\")).toEqual(undefined);\n    });\n\n    test(\"should return undefined when accessing property on number\", () => {\n      expect(get({ a: { b: 2 } }, \"a.b.c\")).toEqual(undefined);\n    });\n\n    test(\"should return undefined when accessing property on string\", () => {\n      expect(get({ a: { b: \"foo\" } }, \"a.b.c\")).toEqual(undefined);\n    });\n  });\n});\n";

// TS Test Cases
const tsTestCode = jsTestCode; 

// JS Test File Name
const jsTestFileName = "submission.spec.ts";

// TS Test File Name
const tsTestFileName = "submission.spec.ts";
// Additional Files
const additionalFiles = {} as Record<string, string>;

const code = {
  jsStarterCode,
  tsStarterCode,
  jsTestCode,
  tsTestCode,
  jsTestFileName,
  tsTestFileName,
  additionalFiles,
} as Record<string, string | Record<string, string>>;

// Export the code object
export default code;
