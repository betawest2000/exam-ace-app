// JS Starter Code
const jsStarterCode = "/**\n * @param {Array} iterable\n * @return {Promise}\n */\nexport default function promiseAny(iterable) {\n  throw \"Not implemented!\";\n}\n";

// TS Starter Code
const tsStarterCode = "export default function promiseAny<T>(iterable: Array<T>): Promise<T> {\n  throw \"Not implemented!\";\n}\n";

// JS Test Cases
const jsTestCode = "import promiseAny from \"./promise-any\";\n\ndescribe(\"promiseAny\", () => {\n  test(\"empty input array\", async () => {\n    expect.assertions(2);\n\n    try {\n      await promiseAny([]);\n    } catch (err: any) {\n      expect(err).toBeInstanceOf(AggregateError);\n      expect(err.errors).toEqual([]);\n    }\n  });\n\n  describe(\"one promise\", () => {\n    describe(\"resolve\", () => {\n      test(\"value\", async () => {\n        expect.assertions(1);\n        const p0 = 2;\n\n        const res = await promiseAny([p0]);\n        expect(res).toEqual(2);\n      });\n\n      test(\"instant\", async () => {\n        expect.assertions(1);\n        const p0 = Promise.resolve(2);\n\n        const res = await promiseAny([p0]);\n        expect(res).toEqual(2);\n      });\n\n      test(\"delayed\", async () => {\n        expect.assertions(1);\n        const p0 = new Promise((resolve) => {\n          setTimeout(() => {\n            resolve(2);\n          }, 10);\n        });\n\n        const res = await promiseAny([p0]);\n        expect(res).toEqual(2);\n      });\n    });\n\n    describe(\"reject\", () => {\n      test(\"instant\", async () => {\n        expect.assertions(2);\n        const p0 = Promise.reject(2);\n\n        try {\n          await promiseAny([p0]);\n        } catch (err: any) {\n          expect(err).toBeInstanceOf(AggregateError);\n          expect(err.errors).toEqual([2]);\n        }\n      });\n\n      test(\"delayed\", async () => {\n        expect.assertions(2);\n        const p0 = new Promise((_, reject) => {\n          setTimeout(() => {\n            reject(2);\n          }, 10);\n        });\n\n        try {\n          await promiseAny([p0]);\n        } catch (err: any) {\n          expect(err).toBeInstanceOf(AggregateError);\n          expect(err.errors).toEqual([2]);\n        }\n      });\n    });\n  });\n\n  describe(\"multiple promises\", () => {\n    describe(\"all resolve\", () => {\n      test(\"instant\", async () => {\n        expect.assertions(1);\n        const p0 = Promise.resolve(2);\n        const p1 = Promise.resolve(3);\n\n        const res = await promiseAny([p0, p1]);\n        expect(res).toEqual(2);\n      });\n\n      test(\"delayed\", async () => {\n        expect.assertions(1);\n        const p0 = Promise.resolve(2);\n        const p1 = new Promise((resolve) => {\n          setTimeout(() => {\n            resolve(3);\n          }, 10);\n        });\n\n        const res = await promiseAny([p0, p1]);\n        expect(res).toEqual(2);\n      });\n\n      test(\"mixture\", async () => {\n        expect.assertions(1);\n        const p0 = new Promise((resolve) => {\n          setTimeout(() => {\n            resolve(2);\n          }, 10);\n        });\n        const p1 = Promise.resolve(3);\n        const p2 = 4;\n\n        const res = await promiseAny([p0, p1, p2]);\n        expect(res).toEqual(3);\n      });\n\n      test(\"many delayed\", async () => {\n        expect.assertions(1);\n        const p0 = new Promise((resolve) => {\n          setTimeout(() => {\n            resolve(1);\n          }, 200);\n        });\n        const p1 = new Promise((resolve) => {\n          setTimeout(() => {\n            resolve(2);\n          }, 100);\n        });\n        const p2 = new Promise((resolve) => {\n          setTimeout(() => {\n            resolve(3);\n          }, 10);\n        });\n\n        const res = await promiseAny([p0, p1, p2]);\n        expect(res).toEqual(3);\n      });\n    });\n\n    describe(\"all reject\", () => {\n      test(\"instant\", async () => {\n        expect.assertions(2);\n        const p0 = Promise.reject(2);\n        const p1 = Promise.reject(3);\n\n        try {\n          await promiseAny([p0, p1]);\n        } catch (err: any) {\n          expect(err).toBeInstanceOf(AggregateError);\n          expect(err.errors).toEqual([2, 3]);\n        }\n      });\n\n      test(\"delayed\", async () => {\n        expect.assertions(2);\n        const p0 = new Promise((_, reject) => {\n          setTimeout(() => {\n            reject(3);\n          }, 1);\n        });\n        const p1 = new Promise((_, reject) => {\n          setTimeout(() => {\n            reject(2);\n          }, 10);\n        });\n\n        try {\n          await promiseAny([p0, p1]);\n        } catch (err: any) {\n          expect(err).toBeInstanceOf(AggregateError);\n          expect(err.errors).toEqual([3, 2]);\n        }\n      });\n\n      test(\"mixture\", async () => {\n        expect.assertions(2);\n        const p0 = Promise.reject(42);\n        const p1 = new Promise((_, reject) => {\n          setTimeout(() => {\n            reject(2);\n          }, 10);\n        });\n\n        try {\n          await promiseAny([p0, p1]);\n        } catch (err: any) {\n          expect(err).toBeInstanceOf(AggregateError);\n          expect(err.errors).toEqual([42, 2]);\n        }\n      });\n    });\n\n    describe(\"mix of resolve and reject\", () => {\n      test(\"instant resolve delayed reject\", async () => {\n        expect.assertions(1);\n        const p0 = Promise.resolve(42);\n        const p1 = new Promise((_, reject) => {\n          setTimeout(() => {\n            reject(2);\n          }, 10);\n        });\n\n        const res = await promiseAny([p0, p1]);\n        expect(res).toEqual(42);\n      });\n\n      test(\"instant resolve instant reject\", async () => {\n        expect.assertions(1);\n        const p0 = Promise.resolve(42);\n        const p1 = Promise.reject(2);\n\n        const res = await promiseAny([p0, p1]);\n        expect(res).toEqual(42);\n      });\n\n      test(\"instant reject instant resolve\", async () => {\n        expect.assertions(1);\n        const p0 = Promise.reject(42);\n        const p1 = Promise.resolve(2);\n\n        const res = await promiseAny([p0, p1]);\n        expect(res).toEqual(2);\n      });\n\n      test(\"instant rejects\", async () => {\n        expect.assertions(2);\n        const p0 = Promise.reject(42);\n        const p1 = Promise.reject(43);\n\n        try {\n          await promiseAny([p0, p1]);\n        } catch (err: any) {\n          expect(err).toBeInstanceOf(AggregateError);\n          expect(err.errors).toEqual([42, 43]);\n        }\n      });\n\n      test(\"delayed resolve\", async () => {\n        expect.assertions(1);\n        const p0 = new Promise((resolve) => {\n          setTimeout(() => {\n            resolve(1);\n          }, 100);\n        });\n        const p1 = new Promise((_, reject) => {\n          setTimeout(() => {\n            reject(2);\n          }, 10);\n        });\n        const p2 = new Promise((resolve) => {\n          setTimeout(() => {\n            resolve(3);\n          }, 200);\n        });\n\n        await expect(promiseAny([p0, p1, p2])).resolves.toBe(1);\n      });\n\n      test(\"delayed reject\", async () => {\n        expect.assertions(2);\n        const p0 = new Promise((_, reject) => {\n          setTimeout(() => {\n            reject(1);\n          }, 200);\n        });\n        const p1 = new Promise((_, reject) => {\n          setTimeout(() => {\n            reject(2);\n          }, 100);\n        });\n        const p2 = new Promise((_, reject) => {\n          setTimeout(() => {\n            reject(3);\n          }, 10);\n        });\n\n        try {\n          await promiseAny([p0, p1, p2]);\n        } catch (err: any) {\n          expect(err).toBeInstanceOf(AggregateError);\n          expect(err.errors).toEqual([1, 2, 3]);\n        }\n      });\n    });\n  });\n});\n";

// TS Test Cases
const tsTestCode = jsTestCode; 

// JS Test File Name
const jsTestFileName = "submission.spec.ts";

// TS Test File Name
const tsTestFileName = "submission.spec.ts";
// Additional Files
const additionalFiles = {} as Record<string, string>;

const code = {
  jsStarterCode,
  tsStarterCode,
  jsTestCode,
  tsTestCode,
  jsTestFileName,
  tsTestFileName,
  additionalFiles,
} as Record<string, string | Record<string, string>>;

// Export the code object
export default code;
