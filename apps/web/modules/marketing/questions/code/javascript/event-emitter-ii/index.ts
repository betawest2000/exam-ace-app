// JS Starter Code
const jsStarterCode = "// You are free to use alternative approaches of\n// instantiating the EventEmitter as long as the\n// default export is correct.\nexport default class EventEmitter {\n  constructor() {\n    throw \"Not implemented!\";\n  }\n\n  /**\n   * @param {string} eventName\n   * @param {Function} listener\n   * @returns {{off: Function}}\n   */\n  on(eventName, listener) {\n    throw \"Not implemented!\";\n  }\n\n  /**\n   * @param {string} eventName\n   * @param {...any} args\n   * @returns boolean\n   */\n  emit(eventName, ...args) {\n    throw \"Not implemented!\";\n  }\n}\n";

// TS Starter Code
const tsStarterCode = "interface IEventEmitter {\n  on(eventName: string, listener: Function): { off: () => void };\n  emit(eventName: string, ...args: Array<any>): boolean;\n}\n\n// You are free to use alternative approaches of\n// instantiating the EventEmitter as long as the\n// default export is correct.\nexport default class EventEmitter implements IEventEmitter {\n  constructor() {\n    throw \"Not implemented!\";\n  }\n\n  on(eventName: string, listener: Function): { off: () => void } {\n    throw \"Not implemented!\";\n  }\n\n  emit(eventName: string, ...args: Array<any>): boolean {\n    throw \"Not implemented!\";\n  }\n}\n";

// JS Test Cases
const jsTestCode = "import EventEmitter from \"./event-emitter-ii\";\n\ndescribe(\"EventEmitter\", () => {\n  test(\"constructor\", () => {\n    const emitter = new EventEmitter();\n    expect(emitter).toBeInstanceOf(EventEmitter);\n  });\n\n  describe(\"subscribe\", () => {\n    test(\"returns object with off() method\", () => {\n      const emitter = new EventEmitter();\n      const sub = emitter.on(\"foo\", () => {});\n\n      expect(sub).toBeTruthy();\n      expect(sub.off).toBeTruthy();\n    });\n\n    test(\"single listener\", () => {\n      const emitter = new EventEmitter();\n      let a = 0;\n      emitter.on(\"foo\", () => {\n        a = 1;\n      });\n      emitter.emit(\"foo\");\n\n      expect(a).toBe(1);\n    });\n\n    test(\"multiple listeners\", () => {\n      const emitter = new EventEmitter();\n      let a = 0,\n        b = 1;\n      emitter.on(\"foo\", () => {\n        a = 1;\n      });\n      emitter.on(\"foo\", () => {\n        b = 3;\n      });\n      emitter.emit(\"foo\");\n\n      expect(a).toBe(1);\n      expect(b).toBe(3);\n    });\n\n    test(\"multiple events\", () => {\n      const emitter = new EventEmitter();\n      let a = 0,\n        b = 1;\n      emitter.on(\"foo\", () => {\n        a = 1;\n      });\n      emitter.on(\"bar\", () => {\n        b = 3;\n      });\n      emitter.emit(\"foo\");\n      expect(a).toBe(1);\n      expect(b).toBe(1);\n\n      emitter.emit(\"bar\");\n      expect(b).toBe(3);\n    });\n\n    test(\"same listener added multiple times\", () => {\n      const emitter = new EventEmitter();\n\n      let num = 1;\n      function square() {\n        num *= 2;\n      }\n\n      emitter.on(\"square\", square);\n      emitter.emit(\"square\");\n      expect(num).toBe(2);\n\n      emitter.on(\"square\", square);\n      emitter.emit(\"square\");\n      expect(num).toBe(8);\n    });\n  });\n\n  describe(\"emit\", () => {\n    describe(\"listeners are invoked with arguments\", () => {\n      test(\"single argument\", () => {\n        const emitter = new EventEmitter();\n\n        let sum = 0;\n        emitter.on(\"foo\", (a: number) => {\n          sum = a;\n        });\n        emitter.emit(\"foo\", 3);\n        expect(sum).toBe(3);\n\n        emitter.emit(\"foo\", 5);\n        expect(sum).toBe(5);\n      });\n\n      test(\"two arguments\", () => {\n        const emitter = new EventEmitter();\n\n        let sum = 0;\n        emitter.on(\"foo\", (a: number, b: number) => {\n          sum = a + b;\n        });\n        emitter.emit(\"foo\", 3, 5);\n        expect(sum).toBe(8);\n\n        emitter.emit(\"foo\", 4, 13);\n        expect(sum).toBe(17);\n      });\n\n      test(\"multiple arguments\", () => {\n        const emitter = new EventEmitter();\n\n        let product = 0;\n        emitter.on(\"foo\", (a: number, b: number, c: number) => {\n          product = a * b * c;\n        });\n        emitter.emit(\"foo\", 3, 5, 6);\n        expect(product).toBe(90);\n\n        emitter.emit(\"foo\", 4, 13, 9);\n        expect(product).toBe(468);\n      });\n    });\n\n    describe(\"non-existing event name returns false\", () => {\n      test(\"custom event\", () => {\n        const emitter = new EventEmitter();\n\n        expect(emitter.emit(\"foo\")).toBe(false);\n      });\n\n      test(\"same name as built-in event\", () => {\n        const emitter = new EventEmitter();\n\n        expect(emitter.emit(\"toString\")).toBe(false);\n      });\n    });\n  });\n\n  describe(\"unsubscribe\", () => {\n    test(\"single listener\", () => {\n      const emitter = new EventEmitter();\n\n      let sum = 0;\n      function addTwoNumbers(a: number, b: number) {\n        sum = a + b;\n      }\n      const sub = emitter.on(\"foo\", addTwoNumbers);\n      emitter.emit(\"foo\", 2, 5);\n      expect(sum).toBe(7);\n\n      sub.off();\n      emitter.emit(\"foo\", -3, 9);\n      expect(sum).toBe(7);\n    });\n\n    test(\"multiple listeners\", () => {\n      const emitter = new EventEmitter();\n\n      let sum = 0;\n      function addTwoNumbers(a: number, b: number) {\n        sum = a + b;\n      }\n      const addSub = emitter.on(\"foo\", addTwoNumbers);\n      emitter.emit(\"foo\", 2, 5);\n      expect(sum).toBe(7);\n\n      let product = 0;\n      function multiplyTwoNumbers(a: number, b: number) {\n        product = a * b;\n      }\n      const mulSub = emitter.on(\"foo\", multiplyTwoNumbers);\n      emitter.emit(\"foo\", 4, 5);\n      expect(sum).toBe(9);\n      expect(product).toBe(20);\n\n      addSub.off();\n      emitter.emit(\"foo\", -3, 9);\n      expect(sum).toBe(9);\n      expect(product).toBe(-27);\n\n      mulSub.off();\n      emitter.emit(\"foo\", 3, 7);\n      expect(sum).toBe(9);\n      expect(product).toBe(-27);\n    });\n\n    test(\"multiple events\", () => {\n      const emitter = new EventEmitter();\n\n      let sum = 0;\n      function addTwoNumbers(a: number, b: number) {\n        sum = a + b;\n      }\n      const fooSub = emitter.on(\"foo\", addTwoNumbers);\n      emitter.emit(\"foo\", 2, 5);\n      expect(sum).toBe(7);\n\n      const barSub = emitter.on(\"bar\", addTwoNumbers);\n      emitter.emit(\"bar\", 3, 7);\n      expect(sum).toBe(10);\n\n      fooSub.off();\n      emitter.emit(\"foo\", -3, 9);\n      expect(sum).toBe(10);\n\n      barSub.off();\n      emitter.emit(\"bar\", -3, 9);\n      expect(sum).toBe(10);\n    });\n\n    test(\"same listener added multiple times removed correctly\", () => {\n      const emitter = new EventEmitter();\n\n      let num = 1;\n      function square() {\n        num *= 2;\n      }\n\n      const sub1 = emitter.on(\"square\", square);\n      emitter.emit(\"square\");\n      expect(num).toBe(2);\n\n      const sub2 = emitter.on(\"square\", square);\n      emitter.emit(\"square\");\n      expect(num).toBe(8);\n\n      sub1.off();\n      emitter.emit(\"square\");\n      expect(num).toBe(16);\n\n      sub2.off();\n      emitter.emit(\"square\");\n      expect(num).toBe(16);\n    });\n\n    test(\"sub.off() called more than once doesn't crash\", () => {\n      const emitter = new EventEmitter();\n\n      let sum = 0;\n      function addTwoNumbers(a: number, b: number) {\n        sum = a + b;\n      }\n      const sub = emitter.on(\"foo\", addTwoNumbers);\n      emitter.emit(\"foo\", 2, 5);\n      expect(sum).toBe(7);\n\n      sub.off();\n      emitter.emit(\"foo\", -3, 9);\n      expect(sum).toBe(7);\n\n      sub.off();\n      emitter.emit(\"foo\", -3, 9);\n      expect(sum).toBe(7);\n    });\n  });\n});\n";

// TS Test Cases
const tsTestCode = jsTestCode; 

// JS Test File Name
const jsTestFileName = "submission.spec.ts";

// TS Test File Name
const tsTestFileName = "submission.spec.ts";
// Additional Files
const additionalFiles = {} as Record<string, string>;

const code = {
  jsStarterCode,
  tsStarterCode,
  jsTestCode,
  tsTestCode,
  jsTestFileName,
  tsTestFileName,
  additionalFiles,
} as Record<string, string | Record<string, string>>;

// Export the code object
export default code;
